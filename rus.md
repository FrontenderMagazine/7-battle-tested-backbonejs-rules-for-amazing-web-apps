#7 проверенных в бою правил для веб-приложений написанных на backbone.js

В нашей компании([Bizzabo][1]) мы используем [Backbone.js][2] на протяжении двух лет. Мы начинали с маленького веб-приложения и сейчас у нас есть несколько приложений написанных на Backbone с использованием [Require.js][3] и [Handlebars.js][4].
Приложения на Backbone не придерживаются сторогой архитектуры. Основная идея, которую несет документация: используйте инструменты этого фреймворка так, как вам хочется.
Благодаря такому подходу backbone хорош для абсолютно разных задач и на нем очень просто начать писать приложения. Однако с другой стороны, это приводит к тому, что новички совершают ошибки в самом начале работы с данным фреймворком. 
В процессе мы натыкались на различные подводные камни и находили для них лекарство.
Для того чтобы не повторить наши ошибки, мы предлагаем вам несколько правил и подсказок.

###1. Представления без данных

Данные хранятся в моделях, а не представлениях. В следующий раз когда вы увидите данные в представлении или, еще хуже, в ДОМ, переместите их в модель.
Если у вас нет модели для этих данных, создайте ее:

    this.viewState = new Backbone.Model();

Это позволит вам следить за событиями изменения данных или даже синхронизировать их с сервером, для воссоздания опыта работы в реальном времени.

###2. События ДОМ влияют только на модели

Когда происходит события ДОМ, например нажатие на кнопку, меняйте только модель, не представление.
Изменение ДОМ без изменения модели означает, что вы храните данные в ДОМ.  Данное правило позволит вам избежать не согласованных данных. 
Например, если вы нажали на ссылку "Подробнее", не разварачивайте ваше представление, просто измените данные модели:

    this.viewState.set('readMore', true);

“Отлично, но как тогда изменить представление?” - спросите вы. Отличный вопрос, ответ на него в следующем правиле.

###3. ДОМ изменяется только когда изменяется модель.

События очень крутая штука, используйте их. Наиболее простой подход - перерисовывать всё представление при любом изменении модели:

    this.listenTo(this.stateModel, 'change', this.render);
    
Более правильный подход отрисовывать только необходимые вещи:

    this.listenTo(this.stateModel, 'change:readMore', this.renderReadMore);
    
Представление всегда синхронизировано с моделью. Не имеет значение что повлияло на изменение модели:  
действие пользователя, получение новых данных или отладка приложения в консоли - представление всегда  
будет в курсе этих изменений.

###4. Связанные события и обработчики должны быть вовремя освобождены   

Когда представление удаляется из ДОМ при помощи метода «remove», необходимо удалить все ранее привязанные обработчики событий.
Если вы используете метод «on» для связывания события и обработчика, ваш долг использовать метод «off» для удаления связей. Если этого не сделать сборщик мусора не сможет освободить память и производительность вашего приложения снизится.
В backbone есть специальный метод «listenTo», который позволяет отслеживать к каким обработчикам привязаны события в представлении и удалять связи при вызове метода «remove». Вам достаточно вызвать метод «stopListening» перед удалением представления из ДОМ.

    // Допустимо:
    this.stateModel.on('change:readMore', this.renderReadMore, this);
 
    // Так круче:
    this.listenTo(this.stateModel, 'change:readMore', this.renderReadMore);
    
###5. Всегда сохраняйте возможность использовать цепочки действий

Всегда возвращайте «this» внутри методов «render» и «remove». Это позволит использовать цепочки действий:

    view.render().$el.appendTo(otherElement);
    
Никогда не нарушайте данное соглашение.

###6. События лучше чем обратные вызовы.

Всегда лучше отслеживать события, чем ждать обратного вызова.
В backbone у моделей по умолчанию срабатывают события «sync» и «error» и мы можем это использовать. Сравните два разных подхода:

    model.fetch({
        success: handleSuccess,
        error: handleError
    });
    
И второй вариант:

    view.listenTo(model, 'sync', handleSuccess);
    view.listenTo(model, 'error', handleError);
    model.fetch();
    
Методы «handleSuccess» и «handleError» будут вызваны независимо от того как и где была получена модель.

###7. Представления имеют свою область видимости

Представление никогда не должно работать с той частью ДОМ, которая ей не принадлежит.  
У каждого представления есть ссылка на свою часть ДОМ - «el», либо через элемент jQuery «$el».
Это означает, что вы никогда не должны использовать jQuery напрямую:

    $('.text').html('Thank you');
    
Вместо этого, всегда используйте свою область видимости ДОМ:

    this.$('.text').html('Thank you');
 
    // Тоже самое:
    // this.$el.find('.text').html('Thank you');
    
Если вам надо работать с другим представлением используйте вызов события («trigger») и позвольте другому представлению самому заботиться о своей части ДОМ. Также вы можете использовать Backbone в качестве системы подписки и публикации событий.
В данном примере мы предотвращаем прокрутку страницы:

    var BodyView = Backbone.View.extend({
        initialize: function() {
            this.listenTo(Backbone, 'prevent-scroll', this.preventScroll);
        },
 
        preventScroll: function(prevent) {
            // класс .prevent-scroll использует CSS свойство: overflow: hidden;
            this.$el.toggleClass('prevent-scroll', prevent);
        }
    });
 
    // И далее где-нибудь в нужном месте кода:
    Backbone.trigger('prevent-scroll', true); // запрет прокрутки
    Backbone.trigger('prevent-scroll', false); // разрешение пркрутки
    
###Еще одна вещь

Вы можете многое узнать и понять просто изучая код Backbone. Исследуйте [исходный код с аннотациями][5] для понимания всей «магии». Библиотека достаточно мала и беглое изучение не должно занять у вас более 10 минут.

Данные правила помогают нам писать чистый, красивый и легко читаемый код.
 
 [1]: http://www.bizzabo.com
 [2]: http://backbonejs.org/
 [3]: http://requirejs.org
 [4]: http://handlebarsjs.com/
 [5]: http://backbonejs.org/docs/backbone.html
